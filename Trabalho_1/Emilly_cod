import matplotlib.pyplot as plt
import random
import math

# Parametros 
Tamanho_do_plano = 10000
raio = 100
ponto_inico = (0,0)
ponto_fim = (Tamanho_do_plano,Tamanho_do_plano)

def calcular_distancia(ponto1, ponto2): 
    return math.sqrt((ponto1[0] - ponto2[0])**2 + (ponto1[1] - ponto2[1])**2) #  é a formula Euclidiana basicamente,  melhor forma pelo que eu vi ( a outra que eu tenti ainda tinha sobreposição na diagonal )

quant_obstaculos = int(input("Digite a quantidade de obstáculos: "))

# lista com as cordenadas de onde estão os obstaculos 
mapa_obstaculos = []

# plotando o fundo(lembra de que um obstaculo tbm não deve fica em partes fora da borda ou seja tenho que gerar inteiro dentro das bordas)
fig, ax = plt.subplots()
ax.set_xlim(0, Tamanho_do_plano)
ax.set_ylim(0, Tamanho_do_plano)
ax.set_aspect('equal')
ax.set_facecolor("black")  
ax.axis('off') 

# o pontos inicial e final são fixos (um obstaculo não deve sobrepor esse pontos)
ax.plot(ponto_inico[0], ponto_inico[1], 'go', markersize=10, label='Início')
ax.plot(ponto_fim[0], ponto_fim[1], 'ro', markersize=10, label='Fim')

#criação dos obstaculos 
# - cada obstaculo é um circulo de raio fixo (já defini la em cima )
# - cada circulo é composto por apenas 4 pontos ( cima baixo esquerda direita) criar função para culcular a localização dos pontos baseado no raio 
# - os obstaculos não devem ter nenhuma sobreposição 
# - eles não podem se encostar então nas verificação é sempre maior que o raio( quando botei igual ou maior ele podem gerar obstaculso com um ponto encostado )

for i in range(quant_obstaculos):
    while True: # fazer até que a localizão do i (obstaculo em questão seja valida)
        x = random.uniform(raio, Tamanho_do_plano - raio)
        y = random.uniform(raio, Tamanho_do_plano - raio) # já evito que ele fique para fora das bordas 
        novo_centro = (x, y)
        
        # se colidir com ponto inicial 
        if calcular_distancia(novo_centro, ponto_inico) < raio: 
            continue 
        
        # se colide com ponto final 
        if calcular_distancia(novo_centro, ponto_fim) < raio: 
            continue 
        
        # se ela conlide com algum outro obstaculo 
        if any(calcular_distancia(novo_centro,obstaculo) < 3*raio for obstaculo in mapa_obstaculos): 
            continue
        
        mapa_obstaculos.append(novo_centro)
        break
    #plota o obstaculo 
    circulo = plt.Circle(novo_centro, raio, color='blue', alpha=0.5)
    ax.add_patch(circulo)
    plt.pause(0.15)  

print("Todos obstáculos adicionados!")

ax.legend()
plt.show(block=True)